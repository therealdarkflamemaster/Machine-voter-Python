# E : est l’autorité d’enregistrement des utilisateurs (le serveur qui créer les accés). 登记用户的机构
import colorama
from colorama import Fore
from colorama import Style
from Algorithme.Shuffle import shuffle
from Chiffrrement.Credential import Credential
import Chiffrrement.ElGamal as elgamal


def singleton(classe):
    _instance = {}

    def inner():
        if classe not in _instance:
            _instance[classe] = classe()
        return _instance[classe]

    return inner


@singleton
class Enregistrement:
    # certificate is the public Key of the ElGamal, which is used for playing role of verification the identity of the
    # server
    certificate = "Server-Enregistrement"
    certificate_publicKey = []
    info_voters = []
    pubCns = []
    cns = []

    def __init__(self):
        pass

    def set_certificate(self, publicKey):
        self.certificate_publicKey = publicKey

    def send_certificate(self):
        message = self.certificate
        return elgamal.encrypt(self.certificate_publicKey, message)

    def getInfo_voters(self, info_voters):
        self.info_voters = info_voters
        # Le serveur E génère, pour chaque utilisateur, des identifiants secrets cn et un code de vote Pub(cn).
        print(Fore.GREEN + Style.DIM + "Wait for all the voters to generate its Cn and Pub(Cn) ..." + Style.RESET_ALL)
        self.generate_cn_pubCn()

    def generate_intern_cn(self, x):
        crediential = Credential()
        return crediential.get_cn()

    def generate_pub_cn(self, x):
        crediential = Credential()
        return crediential.generate_pubcn(x.cn, x.uuid)

    def generate_cn_pubCn(self):
        # 遍历赋值
        self.info_voters["cn"] = self.info_voters.apply(self.generate_intern_cn, axis=1)
        self.info_voters["Pub(cn)"] = self.info_voters.apply(self.generate_pub_cn, axis=1)

    # def sendCn_to_voter_dataframe(self, voter):
    #     for info_voter in self.info_voters.iterrows():
    #         # info_voter[1][2] is the para of email
    #         if info_voter[1][2] == voter[1][2]:
    #             # info_voter[1][4] is the para of Cn
    #             return info_voter[1][4]

    def sendCn_to_voter(self, voter):
        for info_voter in self.info_voters.iterrows():
            # info_voter[1][2] is the para of email
            if info_voter[1][2] == voter.mail:
                # info_voter[1][4] is the para of Cn
                voter.set_cn(info_voter[1][4])
                # info_voter[1][4] is the para of Pub(Cn)
                voter.set_pub_cn(info_voter[1][5])
                return [info_voter[1][4], info_voter[1][5]]

    def generate_lists(self):
        self.pubCns = self.info_voters["Pub(cn)"].values.tolist()
        self.cns = self.info_voters["cn"].values.tolist()
        # la liste des codes de vote L = shuffle (Pub(c1); : : : Pub(cN))
        shuffle(self.pubCns)
        print(Fore.GREEN + Style.DIM + "The List L has been generated by server Admin" + Style.RESET_ALL)

    def send_list(self):
        self.generate_lists()
        # Le serveur E envoie la liste des codes de vote L = shuffle (Pub(c1), ... , Pub(cN)) au serveur A
        return self.pubCns

    def delete_list_cn(self):
        # Le serveur E peut supprimer la liste des identifiants secrets cn.
        self.cns = []
